# Web-ларёк

## Описание проекта
Web-ларёк — учебное веб-приложение интернет-магазина с товарами для веб-разработчиков.  
Приложение позволяет просматривать каталог товаров, добавлять товары в корзину и оформлять заказ в два шага.

Основная цель проекта — спроектировать архитектуру веб-приложения с использованием TypeScript и принципов объектно-ориентированного программирования, а также задокументировать выбранные архитектурные решения.

Проект реализован на основе MVP-архитектуры с использованием брокера событий для организации взаимодействия между частями приложения.

---
## Используемый стек
- HTML
- SCSS
- TypeScript
- Webpack    
- Архитектурный паттерн: **MVP (Model–View–Presenter)**  
- Брокер событий (**EventEmitter**)  
- REST API  
---
## Установка и запуск проекта
1. Клонировать репозиторий:
   ```bash
   git clone https://github.com/smirnov-dev-frontend/web-larek-frontend.git
2. Установить зависимости:
   ```bash 
   npm intall
3. В корне проекта создать файл .env и добавить в него:
   ```bash 
   API_ORIGIN=https://larek-api.nomoreparties.co
4. Запустить проект:
   ```bash 
   npm run start
5. Cобрать проект:
   ```bash 
   npm run build
---
## Архитектура приложения
### Общий подход
В проекте используется архитектурный паттерн **MVP (Model–View–Presenter)**.
Архитектура разделена на следующие слои:
- **Model** — данные и бизнес-логика;
- **View** — отображение и работа с DOM;
- **Presenter** — связующий слой между Model и View;
- **Инфраструктурный слой** — API-клиент, брокер событий, утилиты.
Взаимодействие между частями приложения реализовано через брокер событий, что обеспечивает слабую связанность компонентов и упрощает масштабирование приложения.
---
### Инфраструктурный слой
#### Component
**Component** — базовый абстрактный класс для всех компонентов пользовательского интерфейса приложения.
Класс инкапсулирует общую логику работы с DOM и служит основой для всех визуальных компонентов (карточки товаров, списки, корзина, формы, модальные окна).
Класс является дженериком и принимает параметр типа `T`, который описывает структуру данных, используемых для отображения в компоненте.
##### Назначение класса
- централизовать работу с DOM-элементами;
- обеспечить единый интерфейс рендеринга данных;
- исключить дублирование кода в компонентах отображения;
- обеспечить расширяемость и повторное использование компонентов;
##### Конструктор
`constructor(container: HTMLElement)`
##### Параметры конструктора:
- `container: HTMLElement` — корневой DOM-элемент компонента, за отображение которого он отвечает.
##### Поля класса:
- `container: HTMLElement` — хранит ссылку на DOM-элемент компонента.
Повторный поиск DOM-элемента не выполняется.
##### Методы класса
`render(data?: Partial<T>): HTMLElement` - основной метод класса, предназначенный для отображения данных в интерфейсе.
##### Описание работы метода:
- принимает объект данных типа `Partial<T>`;
- сохраняет переданные данные во внутренние поля компонента;
- инициирует обновление DOM через сеттеры полей (в классах-наследниках);
- возвращает ссылку на корневой DOM-элемент компонента;
Предполагается, что:
- конкретные компоненты будут наследоваться от Component;
- в наследниках будут реализованы сеттеры для отдельных свойств данных, которые будут вызываться внутри render;
- сам базовый класс не знает о конкретной структуре DOM.
```bash 
setImage(
  element: HTMLImageElement,
  src: string,
  alt?: string
): void
```
Утилитарный метод для безопасной модификации DOM-элементов `<img>`.
##### Описание работы метода:
- устанавливает значение `src` изображения;
- при наличии параметра `alt` устанавливает альтернативный текст;
- используется в компонентах отображения для централизованной работы с изображениями.
---
#### Modal
**Modal** — базовый класс для работы с модальными окнами приложения.
Класс наследуется от `Component<HTMLElement>` и расширяет его логикой управления состоянием модального окна: открытием, закрытием и обработкой пользовательских действий.
Модальные окна используются для:
- просмотра карточки товара;
- отображения корзины;
- оформления заказа;
- вывода сообщений об успешном действии.
##### Назначение класса
- инкапсулировать логику управления модальными окнами;
- обеспечить единый механизм открытия и закрытия модалок;
- централизовать обработку кликов по фону и кнопке закрытия;
- упростить создание конкретных модальных окон (товар, корзина, форма);
##### Конструктор
`constructor(container: HTMLElement, closeButton?: HTMLElement)`
##### Параметры конструктора:
- `container: HTMLElement` — корневой DOM-элемент модального окна;
- `closeButton?: HTMLElement` — DOM-элемент кнопки закрытия;
В конструкторе:
- сохраняются ссылки на DOM-элементы;
- навешиваются обработчики событий для закрытия модального окна;
- инициализируется начальное закрытое состояние.
##### Поля класса:
`container: HTMLElement` — корневой элемент модального окна;\
`closeButton?: HTMLElement` — кнопка закрытия модального окна;\
`isOpen: boolean` — текущее состояние модального окна (открыто / закрыто);
##### Методы класса
`open(): void` - предназначен для открытия модального окна.
- изменяет состояние isOpen на true;
- добавляет CSS-класс, отвечающий за отображение модального окна;
- блокирует прокрутку основного контента страницы (если требуется);  

`close(): void` - предназначен для закрытия модального окна.  
- изменяет состояние isOpen на false;
- удаляет CSS-класс отображения модального окна;
- восстанавливает прокрутку страницы;
- может инициировать событие закрытия через брокер событий;\

`toggle(): void` - вспомогательный метод для переключения состояния модального окна;
- если модальное окно закрыто — вызывает open;
- если открыто — вызывает close;\

`handleOverlayClick(event: MouseEvent): void` - метод-обработчик клика по фону (оверлею) модального окна.
- проверяет, что клик был выполнен вне содержимого модального окна;
- при выполнении условия инициирует закрытие модального окна;
---
#### EventEmitter
**EventEmitter** — брокер событий приложения, реализующий событийно-ориентированное взаимодействие между компонентами архитектуры MVP.
Класс отвечает за передачу сообщений между:
- моделями;
- представлениями;
- презентерами;
- инфраструктурными сервисами.
Использование брокера событий позволяет избежать прямых зависимостей между классами и обеспечивает слабую связанность компонентов.
##### Назначение класса
- централизовать управление событиями приложения;
- реализовать паттерн Publisher–Subscriber;
- исключить прямые вызовы методов между компонентами;
- упростить масштабирование и сопровождение кода;
##### Конструктор
`constructor()` не принимает параметров и инициализирует внутреннее хранилище подписчиков.
##### Поля класса:
`events: Map<string, Set<EventHandler>>` — коллекция событий и их подписчиков, где:
- ключ — имя события;
- значение — набор обработчиков данного события;
##### Методы класса
`on(event: string, handler: EventHandler): void` - предназначен для подписки на событие.
- регистрирует обработчик handler для указанного события;
- если событие ещё не зарегистрировано, создаёт новую запись;
- предотвращает дублирование обработчиков;

`off(event: string, handler: EventHandler): void` - предназначен для отписки от события.
- удаляет обработчик из списка подписчиков события;
- при отсутствии подписчиков очищает запись события;

`emit(event: string, payload?: unknown): void` - предназначен для генерации события.
- последовательно вызывает все обработчики, подписанные на событие;
- передаёт в обработчики данные `payload`;
- не зависит от конкретной реализации подписчиков;

`clear(): void` - предназначен для полной очистки всех событий.
- удаляет все зарегистрированные события и обработчики;
- используется при сбросе состояния приложения или тестировании;
##### Типы данных
`EventHandler`\
Тип функции-обработчика события.\
`type EventHandler = (payload?: unknown) => void;`
##### Примеры событий, используемых в приложении
- `product:selected`
- `cart:add`
- `cart:remove`
- `order:submit`
- `order:success`
- `modal:open`
- `modal:close`
##### Особенности использования
- `EventEmitter` является единственным механизмом коммуникации между слоями;
- классы не знают друг о друге напрямую;
- события описаны и типизированы в `src/types`;
- брокер передаётся в конструкторы классов через внедрение зависимостей;
---
#### Api
**Api** — базовый класс для работы с REST API приложения.
Класс инкапсулирует логику HTTP-запросов и служит единой точкой взаимодействия приложения с сервером.
Класс не зависит от компонентов отображения и не содержит бизнес-логики приложения.
Используется моделями для получения и отправки данных.
##### Назначение класса
- централизовать работу с сетевыми запросами;
- исключить дублирование кода HTTP-логики;
- обеспечить единообразную обработку ответов и ошибок;
- упростить замену или расширение API в будущем;
##### Конструктор
`constructor(baseUrl: string, options?: RequestInit)`
##### Параметры конструктора:
- `baseUrl: string` — базовый URL API (`https://larek-api.nomoreparties.co`);
- `options?: RequestInit` — базовые параметры запросов (заголовки, метод, credentials);
##### Поля класса:
- `baseUrl: string` — базовый адрес API;
- `options: RequestInit` — базовые настройки запросов;
- `headers: Headers` — набор HTTP-заголовков, используемых во всех запросах;
##### Методы класса
`get<T>(endpoint: string): Promise<T>` - предназначен для выполнения GET-запросов.
- формирует полный URL на основе `baseUrl` и `endpoint`;
- выполняет HTTP-запрос методом GET;
- обрабатывает ответ сервера;
- возвращает данные, приведённые к типу `T`;

`post<T>(endpoint: string, data: unknown): Promise<T>` - предназначен для выполнения POST-запросов.
- сериализует переданные данные в JSON;
- выполняет HTTP-запрос методом POST;
- обрабатывает ответ сервера;
- возвращает данные, приведённые к типу `T`.

`handleResponse<T>(response: Response): Promise<T>` - вспомогательный метод для обработки ответов сервера.
- проверяет статус ответа;
- при успешном ответе возвращает распарсенный JSON;
- при ошибке выбрасывает исключение с описанием ошибки.
##### Типизация
Класс является дженериком на уровне методов (`get<T>`, `post<T>`), что позволяет:
- строго типизировать ответы API;
- избежать использования any;
##### Особенности использования
- экземпляр Api создаётся один раз при инициализации приложения;
- передаётся в модели через конструктор (Dependency Injection);
- не используется напрямую в компонентах отображения;
- все эндпоинты и форматы данных описаны в `src/types`;\
`ProductModel` использует Api для загрузки каталога товаров;\
`OrderModel` использует Api для отправки данных заказа;
Модели не знают о реализации `fetch`, работая только с абстракцией API;
---
### Отображения (View)
Компоненты отображения отвечают за работу с DOM и визуальное представление данных.
Каждый компонент:
- управляет только своим DOM-фрагментом;
- хранит используемые DOM-элементы в полях класса;
- не содержит бизнес-логики;
- взаимодействует с внешним миром через события.
#### ModalView
**ModalView** — базовый класс для модальных окон в приложении.
Обеспечивает открытие, закрытие и управление поведением модального окна, включая закрытие по клику вне окна или по кнопке «Закрыть».
##### Назначение класса
- централизовать логику модальных окон;
- унифицировать поведение всех модалок;
- позволить наследовать функциональность для конкретных модальных окон (например, карточка товара, подтверждение заказа);
- работать через DOM без прямого вмешательства в бизнес-логику;
##### Конструктор
`constructor(container: HTMLElement)`\
##### Параметры конструктора:
`container: HTMLElement` — корневой DOM-элемент модального окна. Этот элемент содержит все внутренние элементы модалки (контент, кнопки, фон).
##### Поля класса:
`container: HTMLElement` — хранит ссылку на корневой элемент модального окна;\
`closeButton: HTMLElement | null` — кнопка закрытия окна (крестик);\
`overlay: HTMLElement | null` — фон модального окна, который при клике закрывает окно;\
`isOpen: boolean `— состояние модального окна (открыто/закрыто);
##### Методы класса:
`open(): void`\
- открывает модальное окно;
- добавляет CSS-класс для отображения;
- навешивает обработчики клика на overlay и closeButton;
- обновляет поле isOpen;

`close(): void`\
- закрывает модальное окно;
- снимает CSS-класс отображения;
- удаляет обработчики клика;
- обновляет поле isOpen;

`toggle(): void`\
- переключает состояние модального окна (открыть/закрыть);
- удобно для тестирования и переиспользования;

`setContent(content: HTMLElement | string): void`\
- задаёт содержимое модального окна;
- если передана строка, превращает её в HTML;
- если передан HTMLElement, вставляет его внутрь контейнера;
##### События:
`modal:open` — вызывается при открытии окна;\
`modal:close` — вызывается при закрытии окна;\
Используются для интеграции с EventEmitter и другими компонентами приложения.
---
#### ProductCardView

**ProductCardView** — компонент отображения карточки товара.
Отвечает за визуализацию информации о товаре (название, цена, изображение, статус в корзине) и за генерацию событий взаимодействия пользователя с карточкой.
##### Назначение класса
- показ информации о товаре в виде карточки;
- реагирование на действия пользователя (выбор товара, добавление/удаление из корзины);
- интеграция с управляющим слоем через события, без прямого вызова методов моделей;
- переиспользование для любого списка товаров.
##### Конструктор
`constructor(container: HTMLElement)`\
##### Параметры конструктора:
`container: HTMLElement` — корневой DOM-элемент карточки, в котором будет отображаться весь контент карточки (изображение, название, цена, кнопки).
##### Поля класса:
`container: HTMLElement` — корневой DOM элемент карточки;\
`titleElement: HTMLElement | null` — элемент для отображения названия товара;\
`priceElement: HTMLElement | null` — элемент для отображения цены;\
`imageElement: HTMLImageElement | null` — элемент для изображения товара;\
`buttonElement: HTMLElement | null` — кнопка добавления/удаления товара из корзины;\
`isInCart: boolean` — состояние товара в корзине;\
##### Методы класса:
`render(data: ProductCardViewData): HTMLElement` - главный метод отображения карточки;\
- принимает объект данных ProductCardViewData с полями:
-- `id: string` — уникальный идентификатор товара;
-- `title: string` — название товара;
-- `price: string` — цена товара;
-- `isInCart: boolean` — находится ли товар в корзине;
- обновляет DOM-элементы карточки (название, цена, изображение, состояние кнопки);
- возвращает корневой элемент container;

`setSelected(selected: boolean): void`\
- отмечает карточку как выбранную;
- может подсвечивать карточку или показывать модальное окно;

`setImage(element: HTMLImageElement, src: string, alt?: string): void` - утилитарный метод для безопасного изменения изображения;\
используется для обновления `imageElement` с возможностью установки `alt`.

`bindEvents(): void`\
- навешивает обработчики событий на кнопку и карточку;
- генерирует события, которые подписаны Presenter’ом через EventEmitter;
- примеры событий: `product:selected, cart:add, cart:remove`.
##### События:
`product:selected` — пользователь кликнул на карточку;\
`cart:add` — товар добавлен в корзину;\
`cart:remove` — товар удалён из корзины.
---
#### ProductListView
**ProductListView** — компонент отображения списка товаров.  
Отвечает за визуализацию набора карточек товаров и управление их рендерингом.
##### Назначение класса
- показывать коллекцию товаров в виде сетки или списка;  
- рендерить отдельные карточки товаров с помощью `ProductCardView`;  
- интегрироваться с управляющим слоем через события, без прямого вызова методов моделей;  
- централизованно управлять обновлением списка при изменении данных.
##### Конструктор 
`constructor(container: HTMLElement)`\
Параметры конструктора:\
`container: HTMLElement` — корневой DOM-элемент для отображения всех карточек товаров.
##### Поля класса:
`container: HTMLElement` — корневой DOM элемент списка;\
`items: ProductCardView[]` — массив компонентов карточек товаров;\
`data: ProductCardViewData[]` — текущее состояние данных для списка товаров.
##### Методы класса:
`render(data: ProductCardViewData[]): HTMLElement` - главный метод для рендеринга списка товаров;
- принимает массив объектов `ProductCardViewData`;
- создаёт или обновляет карточки товаров, используя `ProductCardView`;
- очищает контейнер перед рендерингом новой коллекции;
- возвращает корневой элемент `container`.

`addItem(data: ProductCardViewData): void`\
- добавляет новую карточку товара в список;
- создаёт новый экземпляр ProductCardView;
- навешивает события на карточку.

`clear(): void`\
- очищает список карточек;
- удаляет все дочерние элементы из `container`;
- очищает массив `items`.

`bindEvents(): void`\
- навешивает обработчики событий на все карточки;
- делегирует события ProductCardView через EventEmitter;
- обеспечивает связь с Presenter’ом для обработки выбора товара и добавления в корзину.
##### События:
`product:selected` — пользователь кликнул на карточку;\
`cart:add` — товар добавлен в корзину;\
`cart:remove` — товар удалён из корзины.
---
#### CartView
**CartView** — компонент отображения содержимого корзины.  
Отвечает за визуализацию товаров в корзине, расчёт общей стоимости и управление действиями пользователя (удаление товаров, переход к оформлению заказа).
##### Назначение класса 
- показывать текущие товары в корзине;  
- управлять отображением итоговой суммы;  
- инициировать события для добавления/удаления товаров;  
- взаимодействовать с `Presenter` через события, без прямого вызова методов моделей;  
- обеспечивать централизованное обновление DOM при изменении данных корзины.
##### Конструктор 
`constructor(container: HTMLElement)`
##### Параметры конструктора:
`container: HTMLElement` — корневой DOM-элемент для отображения корзины.
##### Поля класса:
`container: HTMLElement` — корневой DOM элемент корзины;\
`items: HTMLElement[]` — массив DOM-элементов отдельных товаров;\
`data: ApiProduct[]` — текущее состояние товаров в корзине;\
`totalElement: HTMLElement` — элемент для отображения общей стоимости.
##### Методы класса:
`render(data: ApiProduct[]): HTMLElement` - главный метод рендеринга корзины;
- принимает массив товаров `ApiProduct[]`;
- очищает контейнер и создаёт DOM-элементы для каждого товара;
- вызывает `showTotal` для отображения актуальной суммы;
- возвращает корневой элемент `container`.

`showTotal(total: number): void`
- отображает итоговую стоимость корзины;
- обновляет текст в `totalElement`.

`addItem(product: ApiProduct): void`
- добавляет товар в корзину визуально;
- создаёт DOM-элемент для нового продукта;
- навешивает события удаления и взаимодействия с `Presenter`.

`removeItem(productId: string): void`
- удаляет товар из корзины по его id;
- обновляет DOM;
- пересчитывает итоговую сумму.

`bindEvents(): void`
- навешивает обработчики событий на элементы корзины;
- делегирует события `Presenter` через `EventEmitter`:
-- `cart:remove` — удаление товара;
-- `order:submit` — переход к оформлению заказа.
##### События:
`cart:add` — товар добавлен в корзину;\
`cart:remove` — товар удалён из корзины;\
`order:submit` — пользователь инициировал оформление заказа.
---
#### OrderFormView
**OrderFormView** — компонент отображения формы оформления заказа.  
Отвечает за управление всеми шагами оформления, вводом данных пользователя и отображением ошибок валидации.
##### Назначение класса
- показывать форму оформления заказа по шагам;  
- управлять состоянием формы и текущим шагом;  
- проверять корректность введённых данных на клиентской стороне;  
- инициировать события для Presenter’а при отправке заказа;  
- обновлять интерфейс при ошибках или успешной отправке данных.
##### Конструктор 
`constructor(container: HTMLElement)`
##### Параметры конструктора:
`container: HTMLElement` — корневой DOM-элемент формы заказа.
##### Поля класса:
`container: HTMLElement` — корневой элемент формы;\
`currentStep: number` — номер текущего шага оформления;\
`formElements: Record<string, HTMLInputElement>` — словарь всех элементов формы;\
`errorElement: HTMLElement` — элемент для отображения ошибок валидации;\
`submitButton: HTMLButtonElement` — кнопка перехода к следующему шагу или отправки формы.
##### Методы класса:
`render(): HTMLElement` - главный метод рендеринга формы;
- создаёт и вставляет DOM-элементы для текущего шага;
- привязывает обработчики событий для кнопок и полей формы;
- возвращает корневой элемент `container`.

`showError(message: string): void`
- отображает текст ошибки в `errorElement`;
- вызывается при некорректном заполнении полей.

`clear(): void`
- очищает все поля формы;
- сбрасывает текущий шаг и ошибки.

`nextStep(): void`
- переходит к следующему шагу формы;
- проверяет заполнение обязательных полей текущего шага;
- вызывает `showError` при ошибке валидации;
- обновляет интерфейс.

`bindEvents(): void`
- навешивает обработчики событий на элементы формы;
- делегирует события `Presenter` через `EventEmitter`:
-- `order:submit` — отправка данных заказа;
-- `order:success` — успешная обработка заказа.
---



### Модели (Model)

Модели отвечают за хранение данных и бизнес-логику приложения.  
Они не взаимодействуют с DOM и не зависят от компонентов отображения.

#### ProductModel

Отвечает за:
- загрузку каталога товаров через API;
- хранение списка товаров;
- предоставление данных управляющему слою.

#### CartModel

Отвечает за:
- хранение товаров, добавленных в корзину;
- добавление и удаление товаров;
- расчёт итоговой стоимости корзины.

#### OrderModel

Отвечает за:
- хранение данных заказа;
- валидацию данных пользователя (адрес, контакты);
- оформление заказа;
- очистку корзины после успешной оплаты.

---

### Управляющий слой (Presenter)

Presenter связывает модели и отображения:

- подписывается на события от View;
- вызывает методы Model;
- обновляет View при изменении состояния данных.

#### CatalogPresenter

- связывает ProductModel и ProductListView;
- обрабатывает выбор товара;
- управляет отображением модального окна товара.

#### CartPresenter

- связывает CartModel и CartView;
- управляет добавлением и удалением товаров;
- контролирует доступность действий пользователя.

#### OrderPresenter

- управляет процессом оформления заказа;
- проверяет корректность введённых данных;
- завершает оформление заказа.

---

### Событийная модель

Для взаимодействия между слоями используется брокер событий.

Примеры событий:
- `product:selected`
- `cart:add`
- `cart:remove`
- `order:submit`
- `order:success`

Использование событий позволяет избежать прямых зависимостей между компонентами и упрощает расширение приложения.

---

### Типы данных

Типы данных описаны в директории `src/types/`.

В проекте определены:
- типы данных, приходящих с API;
- типы данных, используемые для отображения;
- интерфейсы моделей;
- интерфейсы компонентов отображения;
- интерфейсы базовых классов;
- перечисления и интерфейсы событий.

Типы данных используются для обеспечения строгой типизации и соответствуют описанной архитектуре.
