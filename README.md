# Web-ларёк

## Описание проекта
Web-ларёк — веб-приложение интернет-магазина с товарами для веб-разработчиков.  
Приложение позволяет просматривать каталог товаров, добавлять товары в корзину и оформлять заказ в два шага.

Основная цель проекта — спроектировать архитектуру веб-приложения с использованием TypeScript и принципов объектно-ориентированного программирования, а также задокументировать выбранные архитектурные решения.

Проект реализован на основе MVP-архитектуры с использованием брокера событий для организации взаимодействия между частями приложения.

---
## Используемый стек
- HTML
- SCSS
- TypeScript
- Webpack    
- Архитектурный паттерн: MVP (Model–View–Presenter) 
- Брокер событий (EventEmitter)  
- REST API  
---
## Установка и запуск проекта
1. Клонировать репозиторий:
   ```bash
   git clone https://github.com/smirnov-dev-frontend/web-larek-frontend.git
2. Установить зависимости:
   ```bash 
   npm install
3. В корне проекта создать файл .env и добавить в него:
   ```bash 
   API_ORIGIN=https://larek-api.nomoreparties.co
4. Запустить проект:
   ```bash 
   npm run start
5. Cобрать проект:
   ```bash 
   npm run build
---
## Архитектура приложения
### Общий подход
В проекте используется архитектурный паттерн **MVP (Model–View–Presenter)**.
Архитектура разделена на следующие слои:
- **Model** — данные и бизнес-логика;
- **View** — отображение и работа с DOM;
- **Presenter** — связующий слой между Model и View;
- **Инфраструктурный слой** — API-клиент, брокер событий, утилиты.
Взаимодействие между частями приложения реализовано через брокер событий, что обеспечивает слабую связанность компонентов и упрощает масштабирование приложения.
---
### Инфраструктурный слой
#### Component
**Component** — базовый абстрактный класс для всех компонентов пользовательского интерфейса приложения.
Класс инкапсулирует общую логику работы с DOM и служит основой для всех визуальных компонентов (карточки товаров, списки, корзина, формы, модальные окна).
Класс является дженериком и принимает параметр типа `T`, который описывает структуру данных, используемых для отображения в компоненте.
##### Назначение класса
- централизовать работу с DOM-элементами;
- обеспечить единый интерфейс рендеринга данных;
- исключить дублирование кода в компонентах отображения;
- обеспечить расширяемость и повторное использование компонентов;
##### Конструктор
`constructor(container: HTMLElement)`
##### Параметры конструктора:
- `container: HTMLElement` — корневой DOM-элемент компонента, за отображение которого он отвечает.
##### Поля класса:
- `container: HTMLElement` — хранит ссылку на DOM-элемент компонента.
Повторный поиск DOM-элемента не выполняется.
##### Методы класса
`render(data?: Partial<T>): HTMLElement` - основной метод класса, предназначенный для отображения данных в интерфейсе.
##### Описание работы метода:
- принимает объект данных типа `Partial<T>`;
- сохраняет переданные данные во внутренние поля компонента;
- инициирует обновление DOM через сеттеры полей (в классах-наследниках);
- возвращает ссылку на корневой DOM-элемент компонента;
Предполагается, что:
- конкретные компоненты будут наследоваться от Component;
- в наследниках будут реализованы сеттеры для отдельных свойств данных, которые будут вызываться внутри render;
- сам базовый класс не знает о конкретной структуре DOM.
```bash 
setImage(
  element: HTMLImageElement,
  src: string,
  alt?: string
): void
```
Утилитарный метод для безопасной модификации DOM-элементов `<img>`.
##### Описание работы метода:
- устанавливает значение `src` изображения;
- при наличии параметра `alt` устанавливает альтернативный текст;
- используется в компонентах отображения для централизованной работы с изображениями.
---
#### Modal
**Modal** — базовый класс для работы с модальными окнами приложения.
Класс наследуется от `Component<HTMLElement>` и расширяет его логикой управления состоянием модального окна: открытием, закрытием и обработкой пользовательских действий.
Модальные окна используются для:
- просмотра карточки товара;
- отображения корзины;
- оформления заказа;
- вывода сообщений об успешном действии.
##### Назначение класса
- инкапсулировать логику управления модальными окнами;
- обеспечить единый механизм открытия и закрытия модальных окон;
- централизовать обработку кликов по фону и кнопке закрытия;
- упростить создание конкретных модальных окон (товар, корзина, форма);
##### Конструктор
`constructor(container: HTMLElement, closeButton?: HTMLElement)`
##### Параметры конструктора:
- `container: HTMLElement` — корневой DOM-элемент модального окна;
- `closeButton?: HTMLElement` — DOM-элемент кнопки закрытия;\
В конструкторе:
- сохраняются ссылки на DOM-элементы;
- навешиваются обработчики событий для закрытия модального окна;
- инициализируется начальное закрытое состояние.
##### Поля класса:
`container: HTMLElement` — корневой элемент модального окна;\
`closeButton?: HTMLElement` — кнопка закрытия модального окна;\
`isOpen: boolean` — текущее состояние модального окна (открыто / закрыто);
##### Методы класса
`open(): void` - предназначен для открытия модального окна.
- изменяет состояние `isOpen` на `true`;
- добавляет CSS-класс, отвечающий за отображение модального окна;
- блокирует прокрутку основного контента страницы (если требуется);  

`close(): void` - предназначен для закрытия модального окна.  
- изменяет состояние isOpen на false;
- удаляет CSS-класс отображения модального окна;
- восстанавливает прокрутку страницы;
- может инициировать событие закрытия через брокер событий;

`toggle(): void` - вспомогательный метод для переключения состояния модального окна;
- если модальное окно закрыто — вызывает `open`;
- если открыто — вызывает `close`;

`handleOverlayClick(event: MouseEvent): void` - метод-обработчик клика по фону (оверлею) модального окна.
- проверяет, что клик был выполнен вне содержимого модального окна;
- при выполнении условия инициирует закрытие модального окна;
---
#### EventEmitter
**EventEmitter** — брокер событий приложения, реализующий событийно-ориентированное взаимодействие между компонентами архитектуры MVP.\
Класс отвечает за передачу сообщений между:
- моделями;
- представлениями;
- презентерами;
- инфраструктурными сервисами.
Использование брокера событий позволяет избежать прямых зависимостей между классами и обеспечивает слабую связанность компонентов.
##### Назначение класса
- централизовать управление событиями приложения;
- реализовать паттерн `Publisher–Subscriber`;
- исключить прямые вызовы методов между компонентами;
- упростить масштабирование и сопровождение кода;
##### Конструктор
`constructor()` не принимает параметров и инициализирует внутреннее хранилище подписчиков.
##### Поля класса:
`events: Map<string, Set<EventHandler>>` — коллекция событий и их подписчиков, где:
- ключ — имя события;
- значение — набор обработчиков данного события;
##### Методы класса
`on(event: string, handler: EventHandler): void` - предназначен для подписки на событие.
- регистрирует обработчик `handler` для указанного события;
- если событие ещё не зарегистрировано, создаёт новую запись;
- предотвращает дублирование обработчиков;

`off(event: string, handler: EventHandler): void` - предназначен для отписки от события.
- удаляет обработчик из списка подписчиков события;
- при отсутствии подписчиков очищает запись события;

`emit(event: string, payload?: unknown): void` - предназначен для генерации события.
- последовательно вызывает все обработчики, подписанные на событие;
- передаёт в обработчики данные `payload`;
- не зависит от конкретной реализации подписчиков;

`clear(): void` - предназначен для полной очистки всех событий.
- удаляет все зарегистрированные события и обработчики;
- используется при сбросе состояния приложения или тестировании;
##### Типы данных
`EventHandler`\
Тип функции-обработчика события.\
`type EventHandler = (payload?: unknown) => void;`
##### Примеры событий, используемых в приложении
- `product:selected`
- `cart:add`
- `cart:remove`
- `order:submit`
- `order:success`
- `modal:open`
- `modal:close`
##### Особенности использования
- `EventEmitter` является единственным механизмом коммуникации между слоями;
- классы не знают друг о друге напрямую;
- события описаны и типизированы в `src/types`;
- брокер передаётся в конструкторы классов через внедрение зависимостей;
---
#### Api
**Api** — базовый класс для работы с REST API приложения.
Класс инкапсулирует логику HTTP-запросов и служит единой точкой взаимодействия приложения с сервером.
Класс не зависит от компонентов отображения и не содержит бизнес-логики приложения.
Используется моделями для получения и отправки данных.
##### Назначение класса
- централизовать работу с сетевыми запросами;
- исключить дублирование кода HTTP-логики;
- обеспечить единообразную обработку ответов и ошибок;
- упростить замену или расширение API в будущем;
##### Конструктор
`constructor(baseUrl: string, options?: RequestInit)`
##### Параметры конструктора:
- `baseUrl: string` — базовый URL API (`https://larek-api.nomoreparties.co`);
- `options?: RequestInit` — базовые параметры запросов (заголовки, метод);
##### Поля класса:
- `baseUrl: string` — базовый адрес API;
- `options: RequestInit` — базовые настройки запросов;
- `headers: Headers` — набор HTTP-заголовков, используемых во всех запросах;
##### Методы класса
`get<T>(endpoint: string): Promise<T>` - предназначен для выполнения GET-запросов.
- формирует полный URL на основе `baseUrl` и `endpoint`;
- выполняет HTTP-запрос методом GET;
- обрабатывает ответ сервера;
- возвращает данные, приведённые к типу `T`;

`post<T>(endpoint: string, data: unknown): Promise<T>` - предназначен для выполнения POST-запросов.
- сериализует переданные данные в JSON;
- выполняет HTTP-запрос методом POST;
- обрабатывает ответ сервера;
- возвращает данные, приведённые к типу `T`.

`handleResponse<T>(response: Response): Promise<T>` - вспомогательный метод для обработки ответов сервера.
- проверяет статус ответа;
- при успешном ответе возвращает распарсенный JSON;
- при ошибке выбрасывает исключение с описанием ошибки.
##### Типизация
Класс является дженериком на уровне методов (`get<T>`, `post<T>`), что позволяет:
- строго типизировать ответы API;
- избежать использования any;
##### Особенности использования
- экземпляр Api создаётся один раз при инициализации приложения;
- передаётся в модели через конструктор (Dependency Injection);
- не используется напрямую в компонентах отображения;

`ProductModel` использует Api для загрузки каталога товаров;\
`OrderModel` использует Api для отправки данных заказа;\
Модели не знают о реализации `fetch`, работая только с абстракцией API;

---
### Отображения (View)
Компоненты отображения отвечают за работу с DOM и визуальное представление данных.\
Каждый компонент:
- управляет только своим DOM-фрагментом;
- хранит используемые DOM-элементы в полях класса;
- не содержит бизнес-логики;
- взаимодействует с внешним миром через события.
#### ModalView
**ModalView** — базовый класс для модальных окон в приложении.
Обеспечивает открытие, закрытие и управление поведением модального окна, включая закрытие по клику вне окна или по кнопке «Закрыть».
##### Назначение класса
- централизовать логику модальных окон;
- унифицировать поведение всех модальных окон;
- позволить наследовать функциональность для конкретных модальных окон;
- работать через DOM без прямого вмешательства в бизнес-логику;
##### Конструктор
`constructor(container: HTMLElement)`
##### Параметры конструктора:
`container: HTMLElement` — корневой DOM-элемент модального окна. Этот элемент содержит все внутренние элементы модалки (контент, кнопки, фон).
##### Поля класса:
`container: HTMLElement` — хранит ссылку на корневой элемент модального окна;\
`closeButton: HTMLElement | null` — кнопка закрытия окна;\
`overlay: HTMLElement | null` — фон модального окна, который при клике закрывает окно;\
`isOpen: boolean `— состояние модального окна (открыто/закрыто);
##### Методы класса:
`open(): void`
- открывает модальное окно;
- добавляет CSS-класс для отображения;
- навешивает обработчики клика на `overlay` и `closeButton`;
- обновляет поле `isOpen`;

`close(): void`
- закрывает модальное окно;
- снимает CSS-класс отображения;
- удаляет обработчики клика;
- обновляет поле `isOpen`;

`toggle(): void`
- переключает состояние модального окна (открыть/закрыть);
- удобно для тестирования и переиспользования;

`setContent(content: HTMLElement | string): void`\
- задаёт содержимое модального окна;
- если передана строка, превращает её в HTML;
- если передан HTMLElement, вставляет его внутрь контейнера;
##### События:
`modal:open` — вызывается при открытии окна;\
`modal:close` — вызывается при закрытии окна;\
Используются для интеграции с EventEmitter и другими компонентами приложения.
---
#### ProductCardView

**ProductCardView** — компонент отображения карточки товара.
Отвечает за визуализацию информации о товаре (название, цена, изображение, статус в корзине) и за генерацию событий взаимодействия пользователя с карточкой.
##### Назначение класса
- показ информации о товаре в виде карточки;
- реагирование на действия пользователя (выбор товара, добавление/удаление из корзины);
- интеграция с управляющим слоем через события, без прямого вызова методов моделей;
- переиспользование для любого списка товаров.
##### Конструктор
`constructor(container: HTMLElement)`
##### Параметры конструктора:
`container: HTMLElement` — корневой DOM-элемент карточки, в котором будет отображаться весь контент карточки (изображение, название, цена, кнопки).
##### Поля класса:
`container: HTMLElement` — корневой DOM элемент карточки;\
`titleElement: HTMLElement | null` — элемент для отображения названия товара;\
`priceElement: HTMLElement | null` — элемент для отображения цены;\
`imageElement: HTMLImageElement | null` — элемент для изображения товара;\
`buttonElement: HTMLElement | null` — кнопка добавления/удаления товара из корзины;\
`isInCart: boolean` — состояние товара в корзине;
##### Методы класса:
`render(data: ProductCardViewData): HTMLElement` - главный метод отображения карточки;
- принимает объект данных ProductCardViewData с полями: `id: string` — уникальный идентификатор товара; `title: string` — название товара; `price: string` — цена товара; `isInCart: boolean` — находится ли товар в корзине;
- обновляет DOM-элементы карточки (название, цена, изображение, состояние кнопки);
- возвращает корневой элемент `container`;

`setSelected(selected: boolean): void`
- отмечает карточку как выбранную;
- может подсвечивать карточку или показывать модальное окно;

`setImage(element: HTMLImageElement, src: string, alt?: string): void` - утилитарный метод для безопасного изменения изображения;\
используется для обновления `imageElement` с возможностью установки `alt`.

`bindEvents(): void`
- навешивает обработчики событий на кнопку и карточку;
- генерирует события, которые подписаны `Presenter` через `EventEmitter`;
- примеры событий: `product:selected, cart:add, cart:remove`.
##### События:
`product:selected` — пользователь кликнул на карточку;\
`cart:add` — товар добавлен в корзину;\
`cart:remove` — товар удалён из корзины.
---
#### ProductListView
**ProductListView** — компонент отображения списка товаров.  
Отвечает за визуализацию набора карточек товаров и управление их рендерингом.
##### Назначение класса
- показывать коллекцию товаров в виде сетки или списка;  
- рендерить отдельные карточки товаров с помощью `ProductCardView`;  
- интегрироваться с управляющим слоем через события, без прямого вызова методов моделей;  
- централизованно управлять обновлением списка при изменении данных.
##### Конструктор 
`constructor(container: HTMLElement)`\
##### Параметры конструктора:
`container: HTMLElement` — корневой DOM-элемент для отображения всех карточек товаров.
##### Поля класса:
`container: HTMLElement` — корневой DOM элемент списка;\
`items: ProductCardView[]` — массив компонентов карточек товаров;\
`data: ProductCardViewData[]` — текущее состояние данных для списка товаров.
##### Методы класса:
`render(data: ProductCardViewData[]): HTMLElement` - главный метод для рендеринга списка товаров;
- принимает массив объектов `ProductCardViewData`;
- создаёт или обновляет карточки товаров, используя `ProductCardView`;
- очищает контейнер перед рендерингом новой коллекции;
- возвращает корневой элемент `container`.

`addItem(data: ProductCardViewData): void`
- добавляет новую карточку товара в список;
- создаёт новый экземпляр ProductCardView;
- навешивает события на карточку.

`clear(): void`
- очищает список карточек;
- удаляет все дочерние элементы из `container`;
- очищает массив `items`.

`bindEvents(): void`
- навешивает обработчики событий на все карточки;
- делегирует события ProductCardView через EventEmitter;
- обеспечивает связь с Presenter’ом для обработки выбора товара и добавления в корзину.
##### События:
`product:selected` — пользователь кликнул на карточку;\
`cart:add` — товар добавлен в корзину;\
`cart:remove` — товар удалён из корзины.
---
#### CartView
**CartView** — компонент отображения содержимого корзины.  
Отвечает за визуализацию товаров в корзине, расчёт общей стоимости и управление действиями пользователя (удаление товаров, переход к оформлению заказа).
##### Назначение класса 
- показывать текущие товары в корзине;  
- управлять отображением итоговой суммы;  
- инициировать события для добавления/удаления товаров;  
- взаимодействовать с `Presenter` через события, без прямого вызова методов моделей;  
- обеспечивать централизованное обновление DOM при изменении данных корзины.
##### Конструктор 
`constructor(container: HTMLElement)`
##### Параметры конструктора:
`container: HTMLElement` — корневой DOM-элемент для отображения корзины.
##### Поля класса:
`container: HTMLElement` — корневой DOM элемент корзины;\
`items: HTMLElement[]` — массив DOM-элементов отдельных товаров;\
`data: ApiProduct[]` — текущее состояние товаров в корзине;\
`totalElement: HTMLElement` — элемент для отображения общей стоимости.
##### Методы класса:
`render(data: ApiProduct[]): HTMLElement` - главный метод рендеринга корзины;
- принимает массив товаров `ApiProduct[]`;
- очищает контейнер и создаёт DOM-элементы для каждого товара;
- вызывает `showTotal` для отображения актуальной суммы;
- возвращает корневой элемент `container`.

`showTotal(total: number): void`
- отображает итоговую стоимость корзины;
- обновляет текст в `totalElement`.

`addItem(product: ApiProduct): void`
- добавляет товар в корзину визуально;
- создаёт DOM-элемент для нового продукта;
- навешивает события удаления и взаимодействия с `Presenter`.

`removeItem(productId: string): void`
- удаляет товар из корзины по его id;
- обновляет DOM;
- пересчитывает итоговую сумму.

`bindEvents(): void`
- навешивает обработчики событий на элементы корзины;
- делегирует события `Presenter` через `EventEmitter`:
-- `cart:remove` — удаление товара;
-- `order:submit` — переход к оформлению заказа.
##### События:
`cart:add` — товар добавлен в корзину;\
`cart:remove` — товар удалён из корзины;\
`order:submit` — пользователь инициировал оформление заказа.
---
#### OrderFormView
**OrderFormView** — компонент отображения формы оформления заказа.  
Отвечает за управление всеми шагами оформления, вводом данных пользователя и отображением ошибок валидации.
##### Назначение класса
- показывать форму оформления заказа по шагам;  
- управлять состоянием формы и текущим шагом;  
- проверять корректность введённых данных на клиентской стороне;  
- инициировать события для Presenter’а при отправке заказа;  
- обновлять интерфейс при ошибках или успешной отправке данных.
##### Конструктор 
`constructor(container: HTMLElement)`
##### Параметры конструктора:
`container: HTMLElement` — корневой DOM-элемент формы заказа.
##### Поля класса:
`container: HTMLElement` — корневой элемент формы;\
`currentStep: number` — номер текущего шага оформления;\
`formElements: Record<string, HTMLInputElement>` — словарь всех элементов формы;\
`errorElement: HTMLElement` — элемент для отображения ошибок валидации;\
`submitButton: HTMLButtonElement` — кнопка перехода к следующему шагу или отправки формы.
##### Методы класса:
`render(): HTMLElement` - главный метод рендеринга формы;
- создаёт и вставляет DOM-элементы для текущего шага;
- привязывает обработчики событий для кнопок и полей формы;
- возвращает корневой элемент `container`.

`showError(message: string): void`
- отображает текст ошибки в `errorElement`;
- вызывается при некорректном заполнении полей.

`clear(): void`
- очищает все поля формы;
- сбрасывает текущий шаг и ошибки.

`nextStep(): void`
- переходит к следующему шагу формы;
- проверяет заполнение обязательных полей текущего шага;
- вызывает `showError` при ошибке валидации;
- обновляет интерфейс.

`bindEvents(): void`
- навешивает обработчики событий на элементы формы;
- делегирует события `Presenter` через `EventEmitter`: `order:submit` — отправка данных заказа; `order:success` — успешная обработка заказа.
---
### Управляющий слой (Presenter)

Управляющий слой реализует роль посредника между моделями данных (Model) и компонентами отображения (View).
Presenter не содержит логики работы с DOM и не хранит состояние данных — он управляет процессами и сценариями работы приложения.

Основные задачи слоя:
- связывать модели и отображения;
- реагировать на пользовательские действия;
- вызывать методы моделей;
- подготавливать данные для отображения;
- управлять переходами между состояниями интерфейса;
- обеспечивать слабую связанность между компонентами.
Все взаимодействия в управляющем слое построены на подписке на события и передаче зависимостей через конструктор.
#### Presenter (базовый интерфейс)
**Presenter** — базовый контракт для всех управляющих компонентов приложения.
##### Назначение интерфейса
- определить единый вход в жизненный цикл `presenter`;
- обеспечить единообразие инициализации управляющих компонентов.
##### Методы интерфейса
`init(): void ` 
- выполняет начальную настройку `presenter`;
- регистрирует обработчики событий;
- инициирует первичную загрузку данных.
---
#### CatalogPresenter
**CatalogPresenter** — управляющий компонент каталога товаров.
Отвечает за отображение списка товаров и обработку действий пользователя, связанных с каталогом.
##### Назначение класса
- инициировать загрузку каталога товаров;
- передавать данные о товарах в отображение;
- обрабатывать выбор товара пользователем;
- управлять открытием модального окна товара.
##### Конструктор
`constructor(
  productModel: IProductModel,
  productListView: IProductListView,
  modalView: IModalView,
  events: EventEmitter
)`
##### Параметры конструктора:
`productModel: IProductModel` — модель данных каталога;\
`productListView: IProductListView` — отображение списка товаров;\
`modalView: IModalView` — модальное окно с деталями товара;\
`events: EventEmitter` — брокер событий приложения.
##### Поля класса:
`productModel` — ссылка на модель каталога;\
`productListView` — ссылка на отображение каталога;\
`modalView` — ссылка на компонент модального окна;\
`events` — брокер событий.
##### Методы класса
`init(): void`
- подписывается на события выбора товара;
- инициирует загрузку каталога через модель;
- передаёт данные товаров в отображение.

`handleProductSelect(productId: string): void`
- получает идентификатор выбранного товара;
- запрашивает данные товара из модели;
- передаёт данные в модальное окно;
- инициирует открытие модального окна.
---
#### CartPresenter
**CartPresenter** — управляющий компонент корзины.
Отвечает за синхронизацию состояния корзины с пользовательским интерфейсом.
##### Назначение класса
- обрабатывать добавление и удаление товаров;
- обновлять отображение корзины;
- контролировать доступность действий пользователя;
- рассчитывать итоговую стоимость корзины.
##### Конструктор
`constructor(
  cartModel: ICartModel,
  cartView: ICartView,
  events: EventEmitter
)`
##### араметры конструктора:
`cartModel: ICartModel` — модель корзины;\
`cartView: ICartView` — отображение корзины;\
`events: EventEmitter` — брокер событий.
##### Поля класса:
`cartModel` — ссылка на модель корзины;\
`cartView` — ссылка на отображение корзины;\
`events` — брокер событий приложения.
##### Методы класса
`init(): void`
- одписывается на события изменения корзины;
- инициирует первичное отображение состояния корзины.

`handleAddToCart(productId: string): void`
- запрашивает данные товара;
- добавляет товар в корзину через модель;
- обновляет отображение корзины.

`handleRemoveFromCart(productId: string): void`
- удаляет товар из корзины;
- обновляет список товаров и итоговую стоимость.
---
#### OrderPresenter
**OrderPresenter** — управляющий компонент процесса оформления заказа.
Отвечает за пошаговое оформление заказа и взаимодействие с моделью заказа.
##### Назначение класса
- управлять этапами оформления заказа;
- валидировать пользовательские данные;
- управлять доступностью кнопок перехода;
- инициировать оформление заказа;
- обрабатывать результат оформления.
##### Конструктор
`constructor(
  orderModel: IOrderModel,
  orderFormView: IOrderFormView,
  cartModel: ICartModel,
  events: EventEmitter
)`
##### Параметры конструктора:
`orderModel: IOrderModel` — модель оформления заказа;\
`orderFormView: IOrderFormView` — отображение формы заказа;\
`cartModel: ICartModel` — модель корзины;
`events: EventEmitter` — брокер событий.
##### Поля класса:
- orderModel — ссылка на модель заказа;
- orderFormView — ссылка на отображение формы;
- cartModel — ссылка на модель корзины;
- events — брокер событий приложения.
##### Методы класса
`init(): void`
- подписывается на события формы заказа;
- управляет шагами оформления заказа.

`handleSubmit(data: ApiOrderRequest): void`
- проверяет корректность введённых данных;
- инициирует создание заказа через модель;
- обрабатывает успешное оформление заказа;
- очищает корзину.
---
### Слой данных (Model)

Слой данных отвечает за хранение и управление состоянием приложения, а также за реализацию бизнес-логики.
Модели не взаимодействуют с DOM, не знают о компонентах отображения и не содержат логики пользовательского интерфейса.
Модели:
- инкапсулируют состояние приложения;
- управляют изменением данных;
- взаимодействуют с API;
- предоставляют данные управляющему слою (Presenter);
- инициируют события при изменении состояния.
Все модели взаимодействуют с другими частями приложения исключительно через публичные методы и брокер событий.

#### ProductModel
**ProductModel** — модель данных каталога товаров.
Отвечает за загрузку, хранение и предоставление данных о товарах.
##### Назначение класса
- загрузка каталога товаров с сервера через API;
- хранение списка товаров в памяти приложения;
- предоставление данных о товарах управляющему слою;
- поиск товара по идентификатору.
Класс не зависит от компонентов отображения и не содержит логики интерфейса.
##### Конструктор
`constructor(api: Api, events: EventEmitter)`
##### Параметры конструктора:
`api: Api` — клиент для взаимодействия с серверным API;\
`events: EventEmitter` — брокер событий приложения.
##### Поля класса:
`api: Api` — ссылка на API-клиент;\
`events: EventEmitter` — брокер событий;\
`products: ApiProduct[]` — массив загруженных товаров.
##### Методы класса
`loadProducts(): Promise<void>`
- выполняет запрос к API для получения каталога товаров;
- сохраняет полученные данные во внутреннее поле `products`;
- инициирует событие обновления каталога.

`getProducts(): ApiProduct[]`
- возвращает текущий список товаров;
- используется `presenter` для передачи данных в `View`.

`getProductById(id: string): ApiProduct | undefined`
- выполняет поиск товара по идентификатору;
- возвращает объект товара либо `undefined`, если товар не найден.
---
#### CartModel
**CartModel** — модель данных корзины пользователя.
Отвечает за управление товарами, добавленными в корзину, и расчёт итоговой стоимости.
##### Назначение класса
- хранение товаров, добавленных в корзину;
- добавление и удаление товаров;
- проверка наличия товара в корзине;
- расчёт итоговой стоимости заказа;
- очистка корзины.
##### Конструктор
`constructor(events: EventEmitter)`
##### Поля класса:
`events: EventEmitter` — брокер событий приложения;\
`items: ApiProduct[]` — массив товаров в корзине.
##### Методы класса
`addProduct(product: ApiProduct): void`
- добавляет товар в корзину, если его там ещё нет;
- инициирует событие `cart:add`.

`removeProduct(productId: string): void`
- удаляет товар из корзины по идентификатору;
-инициирует событие `cart:remove`.

`getItems(): ApiProduct[]`
- возвращает текущий список товаров в корзине.

`getTotalPrice(): number`
- рассчитывает суммарную стоимость товаров в корзине.

`clear(): void`
- очищает корзину;
- используется после успешного оформления заказа.
---
#### OrderModel
**OrderModel** — модель данных оформления заказа.
Отвечает за подготовку, валидацию и отправку заказа на сервер.
##### Назначение класса
- хранение данных заказа пользователя;
- валидация пользовательских данных;
- формирование запроса на оформление заказа;
- отправка данных на сервер через API;
- обработка результата оформления заказа.
##### Конструктор
`constructor(api: Api, events: EventEmitter)`
##### Поля класса:
`api: Api` — клиент для отправки заказов;\
`events: EventEmitter` — брокер событий приложения.
##### Методы класса
`createOrder(data: ApiOrderRequest): Promise<ApiOrderResponse>`
- принимает данные заказа;
- выполняет отправку заказа через API;
- возвращает результат оформления заказа;
- инициирует событие `order:success` при успешном выполнении.
---
### Событийная модель
Для взаимодействия между слоями приложения используется брокер событий (EventEmitter).
Событийная модель позволяет:
- избежать прямых зависимостей между Model, View и Presenter;
- изолировать компоненты друг от друга;
- упростить масштабирование и расширение функциональности;
- централизовать обработку пользовательских действий.
Примеры используемых событий:
- `product:selected` — выбор товара в каталоге;
- `cart:add` — добавление товара в корзину;
- `cart:remove` — удаление товара из корзины;
- `order:submit` — отправка формы заказа;
- `order:success` — успешное оформление заказа.
Каждый Presenter подписывается только на необходимые ему события и не зависит от конкретной реализации источника этих событий.
---
### Типы данных
Все типы данных приложения описаны в директории `src/types/`.
Типизация используется для:
- строгого описания данных, приходящих с API;
- описания контрактов моделей, отображений и `presenter`;
- обеспечения согласованности архитектуры;
- предотвращения ошибок на этапе компиляции.

В проекте определены:
- типы API-ответов и запросов;
- интерфейсы моделей (`Model`);
- интерфейсы компонентов отображения (`View`);
- интерфейсы управляющих компонентов (`Presenter`);
- интерфейсы базовых классов;
- перечисления и типы событий.

Типы данных полностью соответствуют архитектуре MVP и используются во всех слоях приложения.
