# Web-ларёк

## Описание проекта
Web-ларёк — учебное веб-приложение интернет-магазина с товарами для веб-разработчиков.  
Приложение позволяет просматривать каталог товаров, добавлять товары в корзину и оформлять заказ в два шага.

Основная цель проекта — спроектировать архитектуру веб-приложения с использованием TypeScript и принципов объектно-ориентированного программирования, а также задокументировать выбранные архитектурные решения.

Проект реализован на основе MVP-архитектуры с использованием брокера событий для организации взаимодействия между частями приложения.

---
## Используемый стек
- HTML
- SCSS
- TypeScript
- Webpack    
- Архитектурный паттерн: **MVP (Model–View–Presenter)**  
- Брокер событий (**EventEmitter**)  
- REST API  
---
## Установка и запуск проекта
1. Клонировать репозиторий:
   ```bash
   git clone https://github.com/smirnov-dev-frontend/web-larek-frontend.git
2. Установить зависимости:
   ```bash 
   npm intall
3. В корне проекта создать файл .env и добавить в него:
   ```bash 
   API_ORIGIN=https://larek-api.nomoreparties.co
4. Запустить проект:
   ```bash 
   npm run start
5. Cобрать проект:
   ```bash 
   npm run build
---
## Архитектура приложения
### Общий подход
В проекте используется архитектурный паттерн **MVP (Model–View–Presenter)**.
Архитектура разделена на следующие слои:
- **Model** — данные и бизнес-логика;
- **View** — отображение и работа с DOM;
- **Presenter** — связующий слой между Model и View;
- **Инфраструктурный слой** — API-клиент, брокер событий, утилиты.
Взаимодействие между частями приложения реализовано через брокер событий, что обеспечивает слабую связанность компонентов и упрощает масштабирование приложения.
---
### Инфраструктурный слой
#### Component
**Component** — базовый абстрактный класс для всех компонентов пользовательского интерфейса приложения.
Класс инкапсулирует общую логику работы с DOM и служит основой для всех визуальных компонентов (карточки товаров, списки, корзина, формы, модальные окна).
Класс является дженериком и принимает параметр типа `T`, который описывает структуру данных, используемых для отображения в компоненте.
##### Назначение класса
- централизовать работу с DOM-элементами;
- обеспечить единый интерфейс рендеринга данных;
- исключить дублирование кода в компонентах отображения;
- обеспечить расширяемость и повторное использование компонентов;
##### Конструктор
`constructor(container: HTMLElement)`
##### Параметры конструктора:
- `container: HTMLElement` — корневой DOM-элемент компонента, за отображение которого он отвечает.
##### Поля класса:
- `container: HTMLElement` — хранит ссылку на DOM-элемент компонента.
Повторный поиск DOM-элемента не выполняется.
##### Методы класса
`render(data?: Partial<T>): HTMLElement` - основной метод класса, предназначенный для отображения данных в интерфейсе.
##### Описание работы метода:
- принимает объект данных типа `Partial<T>`;
- сохраняет переданные данные во внутренние поля компонента;
- инициирует обновление DOM через сеттеры полей (в классах-наследниках);
- возвращает ссылку на корневой DOM-элемент компонента;
Предполагается, что:
- конкретные компоненты будут наследоваться от Component;
- в наследниках будут реализованы сеттеры для отдельных свойств данных, которые будут вызываться внутри render;
- сам базовый класс не знает о конкретной структуре DOM.
```bash 
setImage(
  element: HTMLImageElement,
  src: string,
  alt?: string
): void
```
Утилитарный метод для безопасной модификации DOM-элементов `<img>`.
##### Описание работы метода:
- устанавливает значение `src` изображения;
- при наличии параметра `alt` устанавливает альтернативный текст;
- используется в компонентах отображения для централизованной работы с изображениями.
---
#### Modal
**Modal** — базовый класс для работы с модальными окнами приложения.
Класс наследуется от `Component<HTMLElement>` и расширяет его логикой управления состоянием модального окна: открытием, закрытием и обработкой пользовательских действий.
Модальные окна используются для:
- просмотра карточки товара;
- отображения корзины;
- оформления заказа;
- вывода сообщений об успешном действии.
##### Назначение класса
- инкапсулировать логику управления модальными окнами;
- обеспечить единый механизм открытия и закрытия модалок;
- централизовать обработку кликов по фону и кнопке закрытия;
- упростить создание конкретных модальных окон (товар, корзина, форма);
##### Конструктор
`constructor(container: HTMLElement, closeButton?: HTMLElement)`
##### Параметры конструктора:
- `container: HTMLElement` — корневой DOM-элемент модального окна;
- `closeButton?: HTMLElement` — DOM-элемент кнопки закрытия;
В конструкторе:
- сохраняются ссылки на DOM-элементы;
- навешиваются обработчики событий для закрытия модального окна;
- инициализируется начальное закрытое состояние.
##### Поля класса:
`container: HTMLElement` — корневой элемент модального окна;\
`closeButton?: HTMLElement` — кнопка закрытия модального окна;\
`isOpen: boolean` — текущее состояние модального окна (открыто / закрыто);
##### Методы класса
`open(): void` - предназначен для открытия модального окна.
- изменяет состояние isOpen на true;
- добавляет CSS-класс, отвечающий за отображение модального окна;
- блокирует прокрутку основного контента страницы (если требуется);\
`close(): void` - предназначен для закрытия модального окна.
- изменяет состояние isOpen на false;
- удаляет CSS-класс отображения модального окна;
- восстанавливает прокрутку страницы;
- может инициировать событие закрытия через брокер событий;\
`toggle(): void` - вспомогательный метод для переключения состояния модального окна;
- если модальное окно закрыто — вызывает open;
- если открыто — вызывает close;\
`handleOverlayClick(event: MouseEvent): void` - метод-обработчик клика по фону (оверлею) модального окна.
- проверяет, что клик был выполнен вне содержимого модального окна;
- при выполнении условия инициирует закрытие модального окна;
---
#### EventEmitter
**EventEmitter** — брокер событий приложения, реализующий событийно-ориентированное взаимодействие между компонентами архитектуры MVP.
Класс отвечает за передачу сообщений между:
- моделями;
- представлениями;
- презентерами;
- инфраструктурными сервисами.
Использование брокера событий позволяет избежать прямых зависимостей между классами и обеспечивает слабую связанность компонентов.
##### Назначение класса
- централизовать управление событиями приложения;
- реализовать паттерн Publisher–Subscriber;
- исключить прямые вызовы методов между компонентами;
- упростить масштабирование и сопровождение кода;
##### Конструктор
`constructor()` не принимает параметров и инициализирует внутреннее хранилище подписчиков.
##### Поля класса:
`events: Map<string, Set<EventHandler>>` — коллекция событий и их подписчиков, где:
- ключ — имя события;
- значение — набор обработчиков данного события;
##### Методы класса
`on(event: string, handler: EventHandler): void` - предназначен для подписки на событие.
- регистрирует обработчик handler для указанного события;
- если событие ещё не зарегистрировано, создаёт новую запись;
- предотвращает дублирование обработчиков;\

`off(event: string, handler: EventHandler): void` - предназначен для отписки от события.
- удаляет обработчик из списка подписчиков события;
- при отсутствии подписчиков очищает запись события;\

`emit(event: string, payload?: unknown): void` - предназначен для генерации события.
- последовательно вызывает все обработчики, подписанные на событие;
- передаёт в обработчики данные `payload`;
- не зависит от конкретной реализации подписчиков;\

`clear(): void` - предназначен для полной очистки всех событий.
- удаляет все зарегистрированные события и обработчики;
- используется при сбросе состояния приложения или тестировании;
##### Типы данных
`EventHandler`\
Тип функции-обработчика события.\
`type EventHandler = (payload?: unknown) => void;`
##### Примеры событий, используемых в приложении
- `product:selected`
- `cart:add`
- `cart:remove`
- `order:submit`
- `order:success`
- `modal:open`
- `modal:close`
##### Особенности использования
- `EventEmitter` является единственным механизмом коммуникации между слоями;
- классы не знают друг о друге напрямую;
- события описаны и типизированы в `src/types`;
- брокер передаётся в конструкторы классов через внедрение зависимостей;
---
#### Api
**Api** — базовый класс для работы с REST API приложения.
Класс инкапсулирует логику HTTP-запросов и служит единой точкой взаимодействия приложения с сервером.
Класс не зависит от компонентов отображения и не содержит бизнес-логики приложения.
Используется моделями для получения и отправки данных.
##### Назначение класса
- централизовать работу с сетевыми запросами;
- исключить дублирование кода HTTP-логики;
- обеспечить единообразную обработку ответов и ошибок;
- упростить замену или расширение API в будущем;
##### Конструктор
`constructor(baseUrl: string, options?: RequestInit)`
##### Параметры конструктора:
- `baseUrl: string` — базовый URL API (`https://larek-api.nomoreparties.co`);
- `options?: RequestInit` — базовые параметры запросов (заголовки, метод, credentials);
##### Поля класса:
- `baseUrl: string` — базовый адрес API;
- `options: RequestInit` — базовые настройки запросов;
- `headers: Headers` — набор HTTP-заголовков, используемых во всех запросах;
##### Методы класса
`get<T>(endpoint: string): Promise<T>` - предназначен для выполнения GET-запросов.
- формирует полный URL на основе `baseUrl` и `endpoint`;
- выполняет HTTP-запрос методом GET;
- обрабатывает ответ сервера;
- возвращает данные, приведённые к типу `T`;\

`post<T>(endpoint: string, data: unknown): Promise<T>` - предназначен для выполнения POST-запросов.
- сериализует переданные данные в JSON;
- выполняет HTTP-запрос методом POST;
- обрабатывает ответ сервера;
- возвращает данные, приведённые к типу `T`.\

`handleResponse<T>(response: Response): Promise<T>` - вспомогательный метод для обработки ответов сервера.
- проверяет статус ответа;
- при успешном ответе возвращает распарсенный JSON;
- при ошибке выбрасывает исключение с описанием ошибки.
##### Типизация
Класс является дженериком на уровне методов (`get<T>`, `post<T>`), что позволяет:
- строго типизировать ответы API;
- избежать использования any;
##### Особенности использования
- экземпляр Api создаётся один раз при инициализации приложения;
- передаётся в модели через конструктор (Dependency Injection);
- не используется напрямую в компонентах отображения;
- все эндпоинты и форматы данных описаны в `src/types`;\
`ProductModel` использует Api для загрузки каталога товаров;\
`OrderModel` использует Api для отправки данных заказа;
Модели не знают о реализации `fetch`, работая только с абстракцией API;
---


### Модели (Model)

Модели отвечают за хранение данных и бизнес-логику приложения.  
Они не взаимодействуют с DOM и не зависят от компонентов отображения.

#### ProductModel

Отвечает за:
- загрузку каталога товаров через API;
- хранение списка товаров;
- предоставление данных управляющему слою.

#### CartModel

Отвечает за:
- хранение товаров, добавленных в корзину;
- добавление и удаление товаров;
- расчёт итоговой стоимости корзины.

#### OrderModel

Отвечает за:
- хранение данных заказа;
- валидацию данных пользователя (адрес, контакты);
- оформление заказа;
- очистку корзины после успешной оплаты.

---

### Отображения (View)

Компоненты отображения отвечают за работу с DOM и визуальное представление данных.

Каждый компонент:
- управляет только своим DOM-фрагментом;
- хранит используемые DOM-элементы в полях класса;
- не содержит бизнес-логики;
- взаимодействует с внешним миром через события.

#### ProductCardView

- отображает карточку товара;
- генерирует событие выбора товара.

#### ProductListView

- отображает список товаров;
- рендерит карточки товаров на основе переданных данных.

#### CartView

- отображает содержимое корзины;
- позволяет удалять товары;
- инициирует переход к оформлению заказа.

#### OrderFormView

- отображает формы оформления заказа;
- управляет шагами оформления;
- отображает ошибки валидации.

#### ModalView

Базовый компонент для модальных окон:
- открытие и закрытие модального окна;
- закрытие по клику вне окна;
- обработка кнопки закрытия.

---

### Управляющий слой (Presenter)

Presenter связывает модели и отображения:

- подписывается на события от View;
- вызывает методы Model;
- обновляет View при изменении состояния данных.

#### CatalogPresenter

- связывает ProductModel и ProductListView;
- обрабатывает выбор товара;
- управляет отображением модального окна товара.

#### CartPresenter

- связывает CartModel и CartView;
- управляет добавлением и удалением товаров;
- контролирует доступность действий пользователя.

#### OrderPresenter

- управляет процессом оформления заказа;
- проверяет корректность введённых данных;
- завершает оформление заказа.

---

### Событийная модель

Для взаимодействия между слоями используется брокер событий.

Примеры событий:
- `product:selected`
- `cart:add`
- `cart:remove`
- `order:submit`
- `order:success`

Использование событий позволяет избежать прямых зависимостей между компонентами и упрощает расширение приложения.

---

### Типы данных

Типы данных описаны в директории `src/types/`.

В проекте определены:
- типы данных, приходящих с API;
- типы данных, используемые для отображения;
- интерфейсы моделей;
- интерфейсы компонентов отображения;
- интерфейсы базовых классов;
- перечисления и интерфейсы событий.

Типы данных используются для обеспечения строгой типизации и соответствуют описанной архитектуре.
